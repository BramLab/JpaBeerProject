

Cleanup database inbetween tests:
    https://vladmihalcea.com/clean-up-test-data-spring/

tearDownAll() addShutdownHook
    https://stackoverflow.com/questions/9903341/cleanup-after-all-junit-tests

FeedbackToUserException in genericRepo or in specific service?
    Design doubt:
    - it is more generic to put these FeedbackToUserException in genericRepo,
    - but it seems logical also to have user feedback & interaction coming from the service...
    -> CONFIRM HILAL: validatie in service.

Testing: test mainApp & controllers instead of services?
    TODO: mock scanner...
    https://stackoverflow.com/questions/31635698/junit-testing-for-user-input-using-scanner/31635953#31635953

Concurrent access: handle multiple transactions error-proof.
Update & Delete should either lock (pessimistic) or read version (optimistic, @Version) of record, before change.

DeleteById seems not very safe -> if someone else just updated element values, it will still be deleted.
    What if someone is in the process of updating?
    Is Delete by element safer? -> if it holds its latest (~transaction/em/~session?) state?
    We could verify that the service first loads the latest version and then deletes that one?

=> https://www.baeldung.com/jpa-optimistic-locking   (personal preference)
=> https://www.baeldung.com/jpa-pessimistic-locking



Cascade:

Keep session in service: findById & update (object might change by someone else before own changes committed.
Maybe get separately after findById?

Show all Beers should show categories & brewers, so bypass lazy loading.
-> Eager (always)? is only ManyToOne => not breaking but less beautiful: when showing category.findById also the beers are show, and there the categories are redundantly shown again.



 Optionele uitbreidingen
• H2 in-memory database voor testen

• Abstracte BaseRepository<T> bouwen

• Lazy-loading elegant oplossen
// https://stackoverflow.com/questions/51837798/get-associated-getter-setter-of-field-member-variable
Optimised version by AI:
https://claude.ai/chat/3e5aaab5-b436-4c5f-b2df-4a4b29da6a8f
for (Field field : entity.getClass().getDeclaredFields()) {
    if (Arrays.stream(field.getAnnotations())
            .anyMatch(a -> a.annotationType().getSimpleName().contains("LAZY"))) {

        String getterName = "get" +
            field.getName().substring(0, 1).toUpperCase() +
            field.getName().substring(1);

        try {
            Method getter = entity.getClass().getDeclaredMethod(getterName);
            List<?> result = (List<?>) getter.invoke(entity);
            result.size(); // Force lazy loading
        } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) {
            throw new RuntimeException(e);
        }
    }
}


• @NamedQuery gebruiken (basisopdracht: Gebruik TypedQuery)
https://stackoverflow.com/questions/33236664/difference-between-query-native-query-named-query-and-typed-query
? CriteriaQuery
- Query refers to JPQL/HQL (Java Persistence Query Language & Hibernate Query Language) query with syntax similar to SQL
generally used to execute DML (Data manipulation language) statements (=CRUD operations).

In JPA, you can create a query using    entityManager.createQuery().
In Hibernate, you use                   session.createQuery()"

NativeQuery: refers to actual sql queries (referring to actual database objects).
These queries are the sql statements which can be directly executed in database using a database client.
- JPA :                                 entityManager.createNativeQuery()
- Hibernate (Non-JPA implementation):   session.createSQLQuery()

- NamedQuery: Similar to how the constant is defined. NamedQuery is the way you define your query by giving it a name.
    You could define this in mapping file in hibernate or also using annotations at entity level.

- TypedQuery: gives you an option to mention the type of entity when you create a query and therefore any operation
    hereafter does not need an explicit cast to the intended type.
    Whereas the normal Query API does not return the exact type of Object you expect and you need to cast.


• Command pattern toepassen in MainApp
This site seems to describe a version resembling current Menu (& MenuOption inner class):
    https://ajayiyengar.com/2017/04/12/command-pattern-using-java-8-lambdas/

• Logging (Log4j/SLF4J) toevoegen
Gave a lot of trouble and no advantage. Probably because i didn't use it.
https://logging.apache.org/log4j/2.x/manual/getting-started.html
In pom.xm:
    Log4j 2 is broken up in an API and an implementation (core), where the API provides the interface that applications
    should code to. Strictly speaking Log4j core is only needed at runtime and not at compile time.
Problem json: https://mvnrepository.com/artifact/org.apache.logging.log4j/log4j-layout-template-json


• JSON import/export voor bieren



----------- GenericRepositoryImpl
//    @Override
//    public void delete(EntityManager entityManager, T entity) {
//        entityManager.remove(entityManager.contains(entity) ? entity : entityManager.merge(entity));
//    }
//
//    @Override
//    public void deleteById(EntityManager entityManager, ID id) {
//        T entity = findById(entityManager, id);
//        if (entity != null) {
//            delete(entityManager, entity);
//        }
//    }

---
Also unused:
    public boolean isDetached(Brewer brewer) {
        EntityManager em = JpaConfig.getEntityManager();
        return brewer.getId() != 0  // must not be transient
                && !em.contains(brewer)  // must not be managed now
                && em.find(Brewer.class, brewer.getId()) != null;  // must not have been removed
    }